//! # BPMN Schema
//!
use thiserror::Error;

/// Alias for URI
pub type URI = String;
/// Alias for ID
pub type Id = String;
/// Alias for Integer
pub type Integer = num_bigint::BigInt;
/// Alias for Int
pub type Int = i32;

use downcast_rs::{impl_downcast, Downcast};

pub trait DocumentElementContainer: Downcast {
    fn find_by_id(&self, _id: &str) -> Option<&dyn DocumentElement> {
        None
    }
}
impl_downcast!(DocumentElementContainer);

impl<T> DocumentElementContainer for Vec<T>
where
    T: DocumentElementContainer,
{
    fn find_by_id(&self, id: &str) -> Option<&dyn DocumentElement> {
        for e in self.iter() {
            if let Some(de) = e.find_by_id(id) {
                return Some(de);
            }
        }
        None
    }
}

impl<T> DocumentElementContainer for Option<T>
where
    T: DocumentElementContainer,
{
    fn find_by_id(&self, id: &str) -> Option<&dyn DocumentElement> {
        match self {
            None => None,
            Some(e) => e.find_by_id(id),
        }
    }
}

pub trait DocumentElement: DocumentElementContainer + Send {
    fn element(&self) -> Element;
}

impl_downcast!(DocumentElement);

include!("schema/autogenerated.rs");

#[derive(Error, Debug)]
pub enum EstablishSequenceFlowError {
    #[error("source.id must be Some")]
    NoSourceId,
    #[error("target.id must be Some")]
    NoTargetId,
}

pub fn establish_sequence_flow<F, T, S>(
    source: &mut F,
    target: &mut T,
    id: S,
) -> Result<SequenceFlow, EstablishSequenceFlowError>
where
    F: FlowNodeType + FlowNodeTypeMut,
    T: FlowNodeType + FlowNodeTypeMut,
    S: Into<String>,
{
    let mut sequence_flow = SequenceFlow::default();
    let id_s: Option<String> = Some(id.into());
    sequence_flow.id = id_s.clone();

    if source.id().is_none() {
        return Err(EstablishSequenceFlowError::NoSourceId);
    }

    if target.id().is_none() {
        return Err(EstablishSequenceFlowError::NoTargetId);
    }

    // it is safe now to unwrap ids
    sequence_flow.set_source_ref(source.id().as_ref().unwrap().into());
    sequence_flow.set_target_ref(target.id().as_ref().unwrap().into());

    source.outgoings_mut().push(Outgoing {
        content: id_s.clone(),
    });
    target.incomings_mut().push(Incoming { content: id_s });

    Ok(sequence_flow)
}

#[cfg(test)]
#[test]
fn establishing_sequence_flow() {
    let mut start = StartEvent::default();
    start.id = Some("start".into());
    let mut end = EndEvent::default();
    end.id = Some("end".into());
    let seq_flow = establish_sequence_flow(&mut start, &mut end, "test").unwrap();
    assert_eq!(seq_flow.id(), &Some("test".into()));
    assert_eq!(seq_flow.source_ref(), "start");
    assert_eq!(seq_flow.target_ref(), "end");
    assert_eq!(start.outgoings(), &vec![Some("test".into()).into()]);
    assert_eq!(end.incomings(), &vec![Some("test".into()).into()]);
}

#[cfg(test)]
#[test]
fn failing_to_establish_sequence_flow() {
    let mut start = StartEvent::default();
    let mut end = EndEvent::default();
    assert!(establish_sequence_flow(&mut start, &mut end, "test").is_err());
    start.id = Some("start".into());
    assert!(establish_sequence_flow(&mut start, &mut end, "test").is_err());
    end.id = Some("end".into());
    assert!(establish_sequence_flow(&mut start, &mut end, "test").is_ok());
}

#[cfg(test)]
#[test]
fn find_by_id() {
    let mut proc: Process = Default::default();
    proc.id = Some("proc".into());
    let mut start_event: StartEvent = Default::default();
    start_event.id = Some("start".into());

    proc.flow_elements
        .push(FlowElement::StartEvent(start_event.clone()));

    let mut definitions: Definitions = Default::default();
    definitions
        .root_elements
        .push(RootElement::Process(proc.clone()));
    let proc_ = definitions
        .find_by_id("proc")
        .expect("`proc` should have been found");
    assert_eq!(proc_.element(), Element::Process);
    assert_eq!(proc_.downcast_ref::<Process>().unwrap(), &proc);

    let start_event_ = definitions
        .find_by_id("start")
        .expect("`start` should have been found");
    assert_eq!(start_event_.element(), Element::StartEvent);
    assert_eq!(
        start_event_.downcast_ref::<StartEvent>().unwrap(),
        &start_event
    );

    assert!(definitions.find_by_id("not_to_be_found").is_none());
}
